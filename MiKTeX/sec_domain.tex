\section{Разработка общей структуры микро-ЭВМ}
\label{sec:domain}

В данном разделе приводится функциональный состав разрабатываемой микро-ЭВМ, разработка и описание системы команд, а также описание взаимодействия всех блоков при выполнении команд программы.
\subsection{Функциональный состав микро-ЭВМ}
\label{sub:domain:bayes_net}
Для правильной работы и выполнения операций микро-ЭВМ должна обладать определенным набором функциональных блоков. Этот набор определяется архитектурой разрабатываемой микро-ЭВМ и требованиями, которые предъявляются при проектировании. Опишем набор функциональных блоков микро-ЭВМ для нашего варианта.

Наша микро-ЭВМ состоит из семи основных блоков: устройство управления, блок выборки инструкций, блок выборки операндов, блок выполнения, блок регистров, блок записи результата, память.

Устройство управления выставляет сигналы, необходимые для начала работы других блоков, устанавливает максимальное количество тактов работы для каждого устройства.

Блок выборки инструкций осуществляет выборку и декодирование команд. Этот блок включает в себя блок выборки, блок декодирования. Блок выборки в свою очередь содержит программный счетчик, который указывает на текущую команду в памяти команд. Блок декодирования принимает из памяти команд очередную команду и осуществляет разделение команды на отдельные составляющие (код операции, адреса регистров, памяти и т.д.).

Блок выборки операндов осуществляет загрузку операндов из регистров или RAM.

Блок исполнения предназначен для исполнения команд, поступающих из блока выборки операндов.
Он содержит блоки: стек, арифметико-логическое устройство (АЛУ). АЛУ хранит регистр флагов, который используется при переходе JS.

Блок записи результата осуществляет запись данных в РОН или ОЗУ.

Память в нашей архитектуре разделяется на два модуля.
Первый модуль является памятью команд, который представляет собой синхронную ROM,
тактируемую процессором.
Второй предназначен для хранения данных, над которыми производятся операции.
Память данных является синхронной RAM, и её тактирование также осуществляется процессором.
Оба модуля имеют размер в 1024 слов по два байта, так как размер шины адреса по условию равен 11 бит, а старший бит определяет какому модулю принадлежит адрес. Это позволяет иметь общее адресное пространство для RAM и ROM, так как микро-ЭВМ построена на Принстонской архитектуре. Если старший бит -- 1, то младшие 10 бит -- адрес RAM, в противном случае -- это адрес ROM.

Блок РОН содержит 10 шестнадцатиразрядных регистров, доступ к которым осуществляется за один такт процессорного времени, что позволяет значительно ускорить время обработки данных. Стек содержит 11 шестнадцатиразрядных регистров, объединенных в структуру доступа LIFO (last in first out), что может пригодиться в некоторых операциях обработки данных. Шестнадцатиразрядное АЛУ предназначено для выполнения четырех различных операций, что является главной задачей процессора.

\subsection{Разработка системы команд}
Для того, чтобы процессор мог выполнять определенные действия, необходимые для правильной обработки данных, должен быть разработан четкий набор инструкций, с помощью которого можно записать алгоритм на понятном процессору языке. В таблице 1.1 приведены все команды и способы их кодирования, разработанные в соответствии с заданным вариантом.

Как видно из таблицы 1.1  разрабатываемая микро-ЭВМ «понимает» 16 команд, с помощью которых можно построить различные алгоритмы обработки данных.

Процессор спроектированной системы поддерживает следующие типы адресации в командах АЛУ:
\begin{itemize}
    \item Прямая – адресация, при которой адрес в памяти указывается непосредственно в команде.
    \item Косвенная регистровая – номер регистра, в котором хранится адрес ячейки памяти, указывается непосредственно в команде
\end{itemize}
Также присутствуют команды MOV, позволяющие пересылать данные между регистрами, регистром и памятью, и загружать данные в регистр непосредственно из операнда команды.

Операции PUSH, POP предназначены для работы со стеком и работают с регистрами.

Операции перехода позволяют совершать безусловные переходы и переходы по условию. Операция JS совершает переход в случае, если установлен флаг S (флаг знака, означает, что старший бит результата АЛУ равен 1).
Операция JMP осуществляет безусловный переход.

И, наконец, операция HLT завершает работу процессора, сбрасывает регистры КЭШ и останавливает тактирование.

\begin{table}[ht]
\caption{Список команд микро-ЭВМ}
\label{table:domain:learning:number_of_models}
\centering
  \begin{tabular}{| >{\centering}m{0.1\textwidth}
                  | >{\raggedright}m{0.22\textwidth}
                  | >{\centering}m{0.14\textwidth}
                  | >{\centering}m{0.14\textwidth}
                  | >{\centering}m{0.13\textwidth}
                  | >{\centering\arraybackslash}m{0.11\textwidth}|}
      \hline КОП & Мнемоническая запись команды & Бит[31-16] & Бит[15-12] & Бит[11-8] & Бит[7-4] \\
      \hline 0000 & DEC [reg] & -- & КОП & -- & [reg] \\
      \hline 0001 & AND reg, [reg] & -- & КОП & reg & [reg] \\
      \hline 0010 & NAND reg, [reg] & -- & КОП & reg & [reg] \\
      \hline 0011 & ROR reg, [reg] & -- & КОП & reg & [reg] \\
      \hline 0100 & MOV reg, \$mem & \$mem & КОП & reg & -- \\
      \hline 0101 & PUSH reg & -- & КОП & reg & --  \\
      \hline 0110 & JMP \$mem & \$mem & КОП & -- & -- \\
      \hline 0111 & MOV reg, [reg] & -- & КОП & reg & [reg] \\
      \hline 1000 & DEC reg & -- & КОП & reg & -- \\
      \hline 1001 & AND reg, reg & -- & КОП & reg & reg \\
      \hline 1010 & NAND reg, reg & -- & КОП & reg & reg \\
      \hline 1011 & ROR reg, reg & -- & КОП & reg & reg  \\
      \hline 1100 & MOV \$mem, reg & -- & КОП & reg & -- \\
      \hline 1101 & POP reg & -- & КОП & reg & -- \\
      \hline 1110 & JS \$mem & \$mem & КОП & -- & -- \\
      \hline 1111 & HLT & - & КОП & -- & -- \\
      \hline
  \end{tabular}
\end{table}

В таблице \$mem означает, адрес ячейки памяти. Первый операнд (биты[11-8]) всегда адрес регистра, второй -- адрес ячейки памяти, регистр, или регистр, служащий для косвенной адресвации.
Если второй операнд -- адрес ячейки памяти, то он хранится в старших битах второго слова.
Если он адрес регистра -- хранится в битах[7-4].

Все команды имеют длину в два слова, операнды могут отсутствовать.
Первое и второе слово дополняются нулями.
Расположение операндов не зависит от мнемоники.

\subsection{Описание взаимодействия всех блоков микро-ЭВМ при выполнении команд программы}
Запуск микро-ЭВМ происходит при подаче нулевого сигнала на вход запуска. При этом сигнал попадает в блок выборки блока операций. Блок выборки выставляет на шину адреса команд нулевой адрес РС, по которому расположена первая команда, и формирует сигнал запроса следующей команды из памяти команд.

Блок памяти команд воспринимает сигнал запроса команды и её адрес, выставляет содержимое ячейки памяти, формирует сигнал готовности команды, и отправляет информацию в блок декодирования.

Блок декодирования читает данные с шины данных команд, и, в зависимости от кода операции, сохраняет части прочитанной информации в регистры (например, заносит код операции и адреса операндов в соответствующие регистры). Информация в этих регистрах будет храниться вплоть до её отправки в блок исполнения. Но пока декодеру нужно решить, состоит ли прочитанная команда из одного или двух слов. Если команда состоит из двух слов, то декодер формирует сигнал запроса второго слова команды и отправляет в блок выборки. При этом блок выборки инкрементирует РС и формирует сигнал запроса команды из памяти команд.

Когда все слова операции выбраны и декодированы декодер формирует сигнал готовности блока операций. Это значит, что стадия вычитки и декодирования завершилась и нам нужно ожидать завершения работы блока исполнения (если он занят выполнением своей стадии конвейера).

Как только блок исполнения освобождается, регистры с информацией об операции из блока декодирования копируются в аналогичные регистры блока исполнения. Блок операции начинает вычитывать следующую операцию, а блок исполнения (а точнее устройство управления) устанавливает флаг своей занятости и принимается исполнять команду.

В соответствии с кодом пришедшей операции УУ подает управляющие сигналы на все исполняющие блоки (РОН, стек, АЛУ, кэш), а также «открывает/закрывает» необходимые шины.

Если производится операция над операндами из регистров или непосредственным операндом, то выполнение разбивается на 2 стадии по одному такту на каждую: отправка данных на АЛУ, и сохранение результатов в регистре. Если один из операндов берется из памяти, то подаются соответствующие сигналы на кэш и происходит чтение данных. Чтение данных может длиться разное количество тактов в зависимости от наличия данных в строке и от степени наполненности кэша. Поэтому выполнение таких операций завершается на следующий такт после выдачи кэшем данных.

После завершения работы блока исполнения происходит защелкивание флагов состояния процессора и освобождение флага занятости, после чего блок может начать выполнение следующей операции.

Отдельный «вариант развития» может произойти, если декодер определил, что на вход пришла операция перехода. В этом случае данные в блок исполнения не пересылаются. Если пришла операция безусловного перехода, то в блок выборки подается сигнал для изменения PC, и программа продолжает выполняться с нового адреса. Если в декодер пришла команда JS или JNZ, то в дело вступает предсказатель переходов. По адресу команды происходит предсказание, нужно делать прыжок или нет. Если прыжок нужно делать, то дополнительно необходимо сохранить предыдущий адрес. После того, как предсказание было сделано, мы продолжаем выбирать данные по новому адресу до тех пор, пока блок исполнения занят, ибо по завершении своей операции он может выставить новые флаги, по которым будет известно, насколько правильно было сделано предсказание. Если наш «цифровой оракул» сделал верное предсказание, то мы продолжаем выполнять команды без всяких остановок. Иначе нам необходимо загрузить адрес, который должен быть до предсказания и начать заново вычитывать команды. Это конечно же «собьет» всё выполнение конвейера.

Отдельно стоит сказать о работе кэша. Работа кэша начинается с поступления на его входы одного из сигналов: чтение, запись, дамп. В случае чтения или записи необходимо подать адрес ячейки, с которой будем работать. В начале работы кэш разбивает адрес на 2 части: номер набора и тэг. После этого в блоке тэгов активируется соответствующий набор, и четыре тэга поступают на четыре компаратора, где определяется, произошло ли попадание. В случае попадания происходит выполнение нужной операции (один такт). В случае промаха происходит замещение строки данных из памяти (пять тактов). Причем если в ячейках, которые необходимо заместить,  установлен флаг изменения, то эти ячейки выгружаются в память (девять тактов).

Как видно, работа всей системы происходит благодаря согласованию работы различных блоков. Почти каждый блок «оповещает» следующие блоки о том, что он завершил свою работу и готов предоставить данные. Поэтому в процессоре организована конвейерная обработка данных. Однако конвейер, реализованный в нашем варианте, не согласуется с классическим представлением о конвейере, где время выполнения всех стадий должно быть одинаково, а команды должны быть одинаковой длины и проходить одинаковое количество стадий. Стадии нашего конвейера выполняются чаще всего за разное время, а операции могут не включать каких-то стадий.
Структурная схема микро-ЭВМ приведена на чертеже в приложении А.
